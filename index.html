<!DOCTYPE html>
<html>
<head>
  <title>JS Training</title>
  <meta charset="utf-8">
  <link href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAA/wAAAP///wC0af8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMzMzMzMwADMRERERETMAMxMzMzMxMwAzEyMjIyEzADMSMjIyMTMAMxMjIyMhMwAzEiIiIiEzADMSMjIyMTMAMxIiIiIhMwAzEyMjIyEzADMSIiERETMAMxIiISITMwAzEiIhITMzADMSIiETMzMAMxERETMzMwADMzMzMzMwDAAwAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAADAAwAA" rel="icon" type="image/x-icon">
  <style id="css">
/* LAYOUT */
* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

body {
  max-width: 720px;
  margin: 0 auto;
  font-size: 16px;
  font-family: monospace;
  height: 100vh;
}

pre {
  white-space: pre-wrap;
  padding: 16px;
  margin-top: 32px;
}

h1, h2, h3, h4 { font-weight: normal; margin-top: 16px; }
h1 { text-align: center }

div.CodeMirror { height: 100vh }
.error-message { text-align: center }
.test-flash {
  animation-duration: 6000ms;
  animation-iteration-count: 1;
  animation-fill-mode: forwards;
}

#feedback {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  z-index: 100;
  padding: 24px;
  text-align: center;
  display: none;
}

#feedback label {
  margin-top: 52px;
  display: block;
}
#feedback .range {
  height: 36px;
  display: flex;
  align-items: center;
}

#feedback .min,
#feedback .max,
#feedback input[type="range"] {
  margin: 0 6px;
  width: 33%;
  overflow: hidden;
  text-overflow: ellipsis;
}

#feedback textarea {
  width: 100%;
  margin-top: 18px;
  height: 180px;
  resize: vertical;
  border: none;
  border-radius: 3px;
  font-size: 16px;
  padding: 6px;
  font-weight: bold;
}

#feedback .min { text-align: right }
#feedback .max { text-align: left }

#feedback textarea:focus {
  outline-offset: 3px;
  outline-width: 2px;
  outline-style: dashed;
}
#feedback button {
  border: 2px solid;
  background: transparent;
  padding: 6px;
  border-radius: 8px;
  margin-top: 6px;
  outline: none;
  font-family: monospace;
  font-size: 16px;
  line-height: 22px;
}


/* COLORS */
.editable {
  background-color: var(--b-lime);
}
html, body {
  position: relative;
  color: var(--b);
  background: var(--i);
}

pre {
  background: var(--white);
}

mark {
  background: var(--g-lime);
  color: var(--b);
}

@keyframes pass {
  0% { background-color: var(--e-turquoise); color: var(--a-turquoise) }
  2% { background-color: var(--f-turquoise); color: var(--a-turquoise) }
  4% { background-color: var(--g-turquoise); color: var(--b-turquoise) }
  80% { color: var(--d-turquoise) }
  100% {}
}

@keyframes fail {
  0% { background-color: var(--f-red); color: var(--a-red) }
  2% { background-color: var(--g-red); color: var(--a-red) }
  4% { background-color: var(--i-red); color: var(--b-red) }
  80% { color: var(--d-red) }
  100% {}
}

@keyframes start {
  0% { background-color: var(--e-yellow); color: var(--a-yellow) }
  2% { background-color: var(--f-yellow); color: var(--a-yellow) }
  4% { background-color: var(--g-yellow); color: var(--b-yellow) }
  100% { color: var(--d-yellow) }
}

.error-message { color: var(--g-red) }

#feedback { background: var(--i) }
#feedback .min { color: var(--c-orange) }
#feedback .max { color: var(--c-turquoise) }
#feedback textarea:focus { outline-color: var(--c-turquoise) }
#feedback button:focus { color: var(--c-turquoise) }
#feedback button:hover { color: var(--b-turquoise) }
#feedback button {
  color: var(--b);
  background: white;
}

/* DARK MODE */
.dark #feedback, html.dark, .dark body {
  color: var(--i);
  background: var(--a);
}

.cm-s-dracula span.cm-comment.subject { color: #a3b5ef }
.dark pre { background: var(--b) }
.dark mark {
  background: var(--b-lime);
  color: var(--white);
}

@keyframes pass-dark {
  0% { background-color: var(--g-turquoise); color: var(--white) }
  2% { background-color: var(--e-turquoise); color: var(--white) }
  4% { background-color: var(--b-turquoise); color: var(--g-turquoise) }
  80% { color: var(--f-turquoise) }
  100% {}
}

@keyframes fail-dark {
  0% { background-color: var(--g-red); color: var(--white) }
  2% { background-color: var(--e-red); color: var(--white) }
  4% { background-color: var(--b-red); color: var(--g-red) }
  80% { color: var(--f-red) }
  100% {}
}

@keyframes start-dark {
  0% { background-color: var(--a-yellow); color: var(--white) }
  2% { background-color: var(--c-yellow); color: var(--white) }
  4% { background-color: var(--b-yellow); color: var(--g-yellow) }
  100% { color: var(--f-yellow) }
}

.dark #feedback .min { color: var(--h-orange) }
.dark #feedback .max { color: var(--h-turquoise) }
.dark #feedback textarea:focus { outline-color: var(--h-turquoise) }
.dark #feedback button:focus { color: var(--h-turquoise) }
.dark #feedback button:hover { color: var(--g-turquoise) }
.dark #feedback button {
  color: white;
  background: inherit;
}

/**/
  </style>
<script>
const colorDefs = 'red.orange.yellow.lime.green.turquoise.cyan.blue.purple.fuschia.magenta.pink'.split('.')
document.getElementById('css').innerHTML += `:root {
  --white: #fff;
  --black: #000;
  ${colorDefs.flatMap((name, hue) => [
    `  --${name}: ${hue*30};`,
    ...[...Array(9).keys()].map(i => `  --${(i+10).toString(36)}-${name}: hsl(${hue*30}, 90%, ${(i*10)+10}%);`),
  ]).join('\n')}
  ${[...Array(9).keys()]
    .map(i => `  --${(i+10).toString(36)}: hsl(0, 0%, ${(i*10)+10}%);`).join('\n')}
}
${[...Array(100).keys()].map(n => `
.test-${n}-fail .test-${n} { animation-name: fail }
.test-${n}-pass .test-${n} { animation-name: pass }
.test-${n}-start .test-${n} { animation-name: start }
.dark .test-${n}-fail .test-${n} { animation-name: fail-dark }
.dark .test-${n}-pass .test-${n} { animation-name: pass-dark }
.dark .test-${n}-start .test-${n} { animation-name: start-dark }
`).join('\n')}
`

if (localStorage.theme === 'dark' || (localStorage.theme !== 'light' && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
  document.documentElement.classList.add('dark')
}

</script>
</head>
<body>
  <div id="editor"></div>
  <form id="feedback">
    <label>
      <div class="title">üë∂ How challenging was this exercise ? ü§ñ</div>
      <div class="range">
        <span class="min">not at all</span>
        <input type="range" name="intelligibility" min="1" max="100" step="0.01">
        <span class="max">too much</span>
      </div>
    </label>
    <label>
      <div class="title">ü§∑ Was the subject intelligible ? üîé</div>
      <div class="range">
        <span class="min">incomprehensible</span>
        <input type="range" name="difficulty" min="1" max="100" step="0.01">
        <span class="max">clear</span>
      </div>
    </label>
    <label>
      <div class="title">üò© Was it enjoyable ? üòÄ</div>
      <div class="range">
        <span class="min">tiring</span>
        <input type="range" name="fun" min="1" max="100" step="0.01">
        <span class="max">fun</span>
      </div>
    </label>
    <label>
      <div class="title">üí© Was it compelling ? üëç</div>
      <div class="range">
        <span class="min">boring</span>
        <input type="range" name="interest" min="1" max="100" step="0.01">
        <span class="max">interesting</span>
      </div>
    </label>
    <label>
      <div class="title">üï≥ How much did you learn ? üéì</div>
      <div class="range">
        <span class="min">nothing</span>
        <input type="range" name="payoff" min="1" max="100" step="0.01">
        <span class="max">a lot</span>
      </div>
    </label>
    <label>
      <span class="title">üôè Please say anything you think could help improve this exercise</span>
      <textarea name="remarks"></textarea>
    </label>
    /* --
    <button type="button" tabindex="-1" id="skip-feedback">‚ùå cancel üíî</button>
    -----
    <button type="submit">‚úî Submit üíö</button>
    -- */
  </form>
  <link rel="stylesheet" type="text/css" href="./lib/codemirror.css">
  <script src="./lib/codemirror.js"></script>
  <script type="module">
let _module, _loading, _error, _lock, _worker, _save

const ZAP = '///*/// ‚ö°'
const DEFAULT_TIMEOUT = 5000
const userContent = 'https://raw.githubusercontent.com'
const localhost = new Set(['localhost', '127.0.0.1'])
const getContent = async (url, exercise) => {
  const res = await fetch(`${url}/exercise/${exercise}.js`)
  if (!res.ok) {
    _module && _module.purge()
    throw Error(`Unable to fetch: ${exercise}.js`)
  }
  return (await res.text()).replace(/\r\n/g, '\n')
}

const defaults = (arr, ...args) => args.map((v, i) => arr[i] || v)
const unslash = str => str.replace(/(^\/+|\/+$)/g, '')
const guessUrl = ({ host, pathname, hostname, origin }) => host.endsWith('.github.io')
  ? [userContent, host.split('.')[0], unslash(pathname), 'gh-pages']
  : localhost.has(hostname)
  ? [origin]
  : [userContent, 'nan-academy', 'js-training', 'master']

const importText = code => import(URL.createObjectURL(new Blob([code], {type : 'text/javascript'})))
const baseUrl = `${location.origin}${location.pathname}`
const contentUrl = guessUrl(location).join('/')
const exec = async code => {
  document.body.className = ''
  const worker = (_worker && !_worker.terminated)
    ? _worker
    : (_worker = new Worker('./worker.js', { type: 'module' }))

  const send = (arg, timeout) => new Promise(s => {
    setTimeout(() => {
      s(false)
      if (worker.terminated) return
      worker.terminated = true
      worker.terminate()
    }, timeout || DEFAULT_TIMEOUT)
    if (worker.terminated) return setTimeout(s, 32)
    worker.addEventListener('message', event => s(event.data), { once: true, passive: true })
    worker.postMessage(arg)
  })

  document.body.classList.add(`test-1-start`)
  const { line, error, count } = await send(code, 10000)
    .then(data => data || ({ error: 'TimeoutError: Worker is stuck' }))
  if (error) {
    document.body.className = 'test-0-fail'
    return _error = line > -1
      ? cmEditor.doc.markText(
        { line: line-1, ch: 0 },
        { line, ch: 0 },
        { className: `test-flash test-0` },
      )
      : cmEditor.doc.addLineWidget(
        (line || cmEditor.doc.size)-1,
        document.createTextNode(error),
        { coverGutter: true, noHScroll: true, className: 'error-message' },
      )
  }

  for (const n of Array(count).keys()) {
    document.body.classList.add(`test-${n+1}-start`)
    const minWait = new Promise(s => setTimeout(s, 60))
    const pass = await send(n).catch(false)
    await minWait
    document.body.classList.remove(`test-${n+1}-start`)
    document.body.classList.add(`test-${n+1}-${pass ? 'pass' : 'fail'}`)
  }
}

const loadModule = ({ next, exercises }) => {
  const entries = Object.entries(exercises).map(([k, v], i) => [ k, { ...v, name: k, i }])
  for (const [,e] of entries) {
    e.prev = entries[e.i - 1] && entries[e.i - 1][1]
    e.next = entries[e.i + 1] && entries[e.i + 1][1]
  }
  _module = { next, entries, exercises: Object.fromEntries(entries) }
}

const mark = ({ from: f, to: t, ...opts }) => cmEditor.doc.markText(
  { line: f, ch: 0 },
  { line: t, ch: 0 },
  opts,
)

const countLines = str => {
  let total = 0
  for (const c of str) { c === '\n' && (total++) }
  return total
}

const skipButton = document.getElementById('skip-feedback')
const normalize = ([k, str]) => [k, String(str||'').replace(/‚Üµ/g, '‚Ü≤').replace(/\n/g, '‚Üµ')]
const parametrize = data => `${new URLSearchParams(Object.entries(data).map(normalize))}`
const formatInput = e => `${e.name}_${e.value}`.replace(/~/g, '-')
const encodeFeedback = () => parametrize({
  hash: feedback.hash,
  attempt: localStorage[`${feedback.hash}/attempt`] || 0,
  code: inputs.map(formatInput).join('~'),
})

const decodeFeedback = hash => {
  const stored = localStorage[`${hash}/feedback`]
  if (!stored) return {}
  const encodedValues = new URLSearchParams(stored).get('code')
  const result = {}
  for (const part of encodedValues.split('~')) {
    const [key] = part.split('_', 1)
    result[key] = part.slice(key.length + 1).replace(/‚Üµ/g, '\n')
  }
  return result
}

const closeFeedback = () => {
  feedback.style.display = 'none'
  cmEditor.focus()
  const data = encodeFeedback()
  if (localStorage[`${feedback.hash}/feedback`] === data) return false
  localStorage[`${feedback.hash}/feedback`] = data
  return true
}

const openFeedback = (hash = location.hash) => {
  const prevFeedback = decodeFeedback(hash)
  for (const input of inputs) {
    const v = prevFeedback[input.name]
    v === undefined
      ? (input.value = input.type === 'range' ? 50.01 : '')
      : (v && (input.value = v))
  }
  feedback.hash = hash
  feedback.style.display = 'block'
  inputs.find(e => e.name === 'remarks').focus()
}

window.addEventListener('keydown', e => {
  e.key === 'Escape' && (cmEditor.hasFocus() ? openFeedback() : closeFeedback())
}, { passive: true })

skipButton.addEventListener('click', closeFeedback, { passive: true })
const loadHash = async (sourceHash, replace) => {
  if (_loading) return
  _loading = true
  _save = undefined
  const [exPath, versionPath=''] = sourceHash.replace(/^#(\/?)/, '').split('@')
  const version = versionPath
    ? defaults(unslash(versionPath).split('/'), 'nan-academy', 'js-training', 'gh-pages').join('/')
    : ''
  const url = version ? `${userContent}/${version}` : contentUrl
  const [mod, ex] = defaults(exPath.split('.'), 'hello', 'introduction').map(decodeURIComponent)
  localStorage[`$${mod}.@${version}`]
    ? loadModule(JSON.parse(localStorage[`$${mod}.@${version}`]))
    : (await importText(await (await fetch(`${url}/module/${mod}.js`)).text()).then(exports => {
      const { next, exercises } = exports
      localStorage[`$${mod}.@${version}`] = JSON.stringify({ next, exercises })
      loadModule(exports)
    }))

  _module.purge = () => localStorage.removeItem(`$${mod}.@${version}`)

  const exercise = _module.exercises[ex] || _module.entries[0] && _module.entries[0][1]
  if (!exercise) return cmEditor.setValue('Empty module')
  const hash = `#${mod}.${exercise.name}${version?`@${version}`:''}`
  hash === sourceHash || history[replace ? 'replaceState' : 'pushState']({}, '', `${baseUrl}${hash}`)
  const content = await getContent(url, exercise.name)
  const subjectIndex = content.indexOf(ZAP) + ZAP.length
  const testIndex = content.lastIndexOf(ZAP)
  const subject = content.slice(0, subjectIndex)
  const tests = content.slice(testIndex)
  const code = `\n\n${(localStorage[hash] || content.slice(subjectIndex, testIndex)).trim()}\n\n`
  const subjectLines = countLines(subject)
  const testsLines = countLines(tests)
  const codeLines = countLines(code)
  const size = subjectLines + codeLines

  _error && (_error.clear(), _error = undefined)
  document.body.className = ''
  cmEditor.setValue(`${subject}${code}${tests}`)
  cmEditor.focus()
  cmEditor.setCursor(subjectLines + 2, 0)
  const readOnly = true
  mark({ from: 0, to: subjectLines + 1, readOnly, className: 'subject' })
  mark({ from: subjectLines, to: size, className: 'code' })
  mark({ from: size, to: size + codeLines + 1, readOnly, className: 'tests' })
  _save = () => localStorage[hash] = cmEditor.getValue().slice(subjectIndex, -tests.length).trim()

  let count = 0
  tests.replace(/\nt\(/g, (match, index) => {
    const line = size + countLines(tests.slice(0, index + match.length - 1))
    const matchLines = match.split('\n')
    const lastMatchedLine = matchLines[matchLines.length-1]
    const className = `test-flash test-${++count}`
    mark({ from: line, to: line + 1, className })
  })
  _loading = false
}

const rand = () => Math.random().toString(36).slice(2).padStart(11, '0')
const sess = `session=${localStorage.session || (localStorage.session = rand())}`
const log = localhost.has(location.hostname) ? console.log : (path, data) => {
  typeof data === 'string' || (data = parametrize(data))
  fetch(`https://chupato.com/log/${unslash(path)}?${sess}&${data}`).catch(() => {})
}

const next = () => {
  const [ path, version = '' ] = location.hash.split('@')
  const [ mod, current ] = path.split('.')
  const next = _module.exercises[current] && _module.exercises[current].next
  if (next) return loadHash(`${mod}.${next.name}@${version}`)
  if (_module.next) return loadHash(`${_module.next}@${version}`)
  loadHash('success.congratulation@nan-academy/js-training')
}

const feedback = document.getElementById('feedback')
feedback.onsubmit = e => {
  e.preventDefault()
  if (!closeFeedback()) return
  log('feedback', localStorage[`${feedback.hash}/feedback`])
}
const inputs = [...feedback.querySelectorAll('textarea, input')]

let _lastCode
const runTests = async () => {
  if (_lock) return
  _error && (_error.clear(), _error = undefined)
  const { hash, hostname } = location
  const k = `${hash}/attempt`
  const attempt = localStorage[k] = (Number(localStorage[k]) || 0) + 1
  const code = cmEditor.getValue()
  await (_lock = exec(code)).finally(() => _lock = undefined)
  const fail = Array.from(document.body.classList).some(c => c.endsWith('-fail'))
  const changed = code !== _lastCode
  _lastCode = code
  changed && log(fail ? 'fail' : 'pass', { hash, attempt, code: save() })
  if (fail) return
  await new Promise(s => setTimeout(s, 250))
  next()
  const current = _module.exercises[location.hash.split('@')[0].split('.')[1]]
  if (!current || !current.feedback || localStorage[`${location.hash}/prompted`]) return
  localStorage[`${location.hash}/prompted`] = Date.now()
  await openFeedback(hash)
}

export const cmEditor = CodeMirror(document.getElementById('editor'), {
  mode: 'javascript',
  theme: document.documentElement.classList.contains('dark') ? 'dracula' : 'neo',
  keyMap: 'sublime',
  tabSize: 2,
  lineNumbers: true,
  indentWithTabs: false,
  autoCloseBrackets: true,
  scrollbarStyle: 'null',
  extraKeys: { 'Ctrl-S': runTests, 'Cmd-S': runTests, 'Ctrl-Enter': runTests }
})

const save = () => _save && _save()
cmEditor.on('change', (t => () => (clearTimeout(t), t = setTimeout(save, 200)))())

loadHash(location.hash, true)
  .catch(err => {
    console.error(err)
    _module
      ? _module.purge()
      : localStorage.clear()
    location.hash = ''
  })

addEventListener('hashchange', () => loadHash(location.hash, true))

  </script>
</body>
</html>