<!DOCTYPE html>
<html>
<head>
  <title>JS Training</title>
  <meta charset="utf-8">
  <link href="data:image/x-icon;base64,AAABAAEAEBAQAAEABAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAA/wAAAP///wC0af8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMzMzMzMwADMRERERETMAMxMzMzMxMwAzEyMjIyEzADMSMjIyMTMAMxMjIyMhMwAzEiIiIiEzADMSMjIyMTMAMxIiIiIhMwAzEyMjIyEzADMSIiERETMAMxIiISITMwAzEiIhITMzADMSIiETMzMAMxERETMzMwADMzMzMzMwDAAwAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAADAAwAA" rel="icon" type="image/x-icon">
  <style id="css">
/* LAYOUT */
* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

body {
  max-width: 720px;
  margin: 0 auto;
  font-size: 16px;
  font-family: monospace;
  height: 100vh;
}

pre {
  white-space: pre-wrap;
  padding: 16px;
  margin-top: 32px;
}

h1, h2, h3, h4 { font-weight: normal; margin-top: 16px; }
h1 { text-align: center }

div.CodeMirror { height: 100vh }
.error-message { text-align: center }
.test-flash {
  animation-duration: 6000ms;
  animation-iteration-count: 1;
  animation-fill-mode: forwards;
}

/* COLORS */
.editable {
  background-color: var(--b-lime);
}
html, body {
  color: var(--b);
  background: var(--i);
}

pre {
  background: var(--white);
}

mark {
  background: var(--g-lime);
  color: var(--b);
}

@keyframes pass {
  0% { background-color: var(--g-turquoise); color: var(--white) }
  2% { background-color: var(--e-turquoise); color: var(--white) }
  4% { background-color: var(--b-turquoise); color: var(--g-turquoise) }
  80% { color: var(--f-turquoise) }
  100% {}
}

@keyframes fail {
  0% { background-color: var(--g-red); color: var(--white) }
  2% { background-color: var(--e-red); color: var(--white) }
  4% { background-color: var(--b-red); color: var(--g-red) }
  80% { color: var(--f-red) }
  100% {}
}

@keyframes start {
  0% { background-color: var(--a-yellow); color: var(--white) }
  2% { background-color: var(--c-yellow); color: var(--white) }
  4% { background-color: var(--b-yellow); color: var(--g-yellow) }
  100% { color: var(--f-yellow) }
}

.error-message { color: var(--g-red) }

/* DARK MODE */
html.dark, .dark body {
  color: var(--i);
  background: var(--a);
}

.cm-s-dracula span.cm-comment.subject { color: #a3b5ef }
.dark pre { background: var(--b) }
.dark mark {
  background: var(--b-lime);
  color: var(--white);
}

.dark @keyframes pass {
  0% { background-color: var(--g-turquoise); color: var(--white) }
  2% { background-color: var(--e-turquoise); color: var(--white) }
  4% { background-color: var(--b-turquoise); color: var(--g-turquoise) }
  80% { color: var(--f-turquoise) }
  100% {}
}

.dark @keyframes fail {
  0% { background-color: var(--g-red); color: var(--white) }
  2% { background-color: var(--e-red); color: var(--white) }
  4% { background-color: var(--b-red); color: var(--g-red) }
  80% { color: var(--f-red) }
  100% {}
}

.dark @keyframes start {
  0% { background-color: var(--a-yellow); color: var(--white) }
  2% { background-color: var(--c-yellow); color: var(--white) }
  4% { background-color: var(--b-yellow); color: var(--g-yellow) }
  100% { color: var(--f-yellow) }
}

/**/
  </style>
<script>
const colorDefs = 'red.orange.yellow.lime.green.turquoise.cyan.blue.purple.fuschia.magenta.pink'.split('.')
document.getElementById('css').innerHTML += `:root {
  --white: #fff;
  --black: #000;
  ${colorDefs.flatMap((name, hue) => [
    `  --${name}: ${hue*30};`,
    ...[...Array(9).keys()].map(i => `  --${(i+10).toString(36)}-${name}: hsl(${hue*30}, 90%, ${(i*10)+10}%);`),
  ]).join('\n')}
  ${[...Array(9).keys()]
    .map(i => `  --${(i+10).toString(36)}: hsl(0, 0%, ${(i*10)+10}%);`).join('\n')}
}
${[...Array(100).keys()].map(n => `
.test-${n}-fail .test-${n} { animation-name: fail }
.test-${n}-pass .test-${n} { animation-name: pass }
.test-${n}-start .test-${n} { animation-name: start }
`).join('\n')}
`

</script>
</head>
<body>
  <div id="editor"></div>
  <link rel="stylesheet" type="text/css" href="./lib/codemirror.css">
  <script src="./lib/codemirror.js"></script>
  <script type="module">
const DEFAULT_TIMEOUT = 5000
const DARK = window.matchMedia('(prefers-color-scheme: dark)').matches
  || Boolean(localStorage.dark)

DARK && document.documentElement.classList.add('dark')

const getContent = async (url, exercise) => (await (await fetch(`${url}/exercise/${exercise}.js`)).text())
  .replace(/\r\n/g, '\n')

const userContent = 'https://raw.githubusercontent.com'
const localhost = new Set(['localhost', '127.0.0.1'])
const guessUrl = ({ host, pathname, hostname, origin }) => host.endsWith('.github.io')
  ? [userContent, host.split('.')[0], unslash(pathname), 'gh-pages']
  : localhost.has(hostname)
  ? [origin]
  : [userContent, 'nan-academy', 'js-training', 'master']

let _module, _inPopState, _error, _lock, _worker
const importText = code => import(URL.createObjectURL(new Blob([code], {type : 'text/javascript'})))
const unslash = str => str.replace(/(^\/+|\/+$)/g, '')
const baseUrl = `${location.origin}${location.pathname}`
const contentUrl = guessUrl(location).join('/')
const defaults = (arr, ...args) => args.map((v, i) => arr[i] || v)
const exec = async code => {
  document.body.className = ''
  const worker = (_worker && !_worker.terminated)
    ? _worker
    : (_worker = new Worker('./worker.js', { type: 'module' }))

  const send = (arg, timeout) => new Promise(s => {
    setTimeout(() => {
      s(false)
      if (worker.terminated) return
      worker.terminated = true
      worker.terminate()
    }, timeout || DEFAULT_TIMEOUT)
    if (worker.terminated) return setTimeout(s, 32)
    worker.addEventListener('message', event => s(event.data), { once: true, passive: true })
    worker.postMessage(arg)
  })

  document.body.classList.add(`test-1-start`)
  const { line, error, count } = await send(code, 10000)
    .then(data => data || ({ error: 'TimeoutError: Worker is stuck' }))
  if (error) {
    document.body.className = 'test-0-fail'
    return _error = line > -1
      ? cmEditor.doc.markText(
        { line: line-1, ch: 0 },
        { line, ch: 0 },
        { className: `test-flash test-0` },
      )
      : cmEditor.doc.addLineWidget(
        (line || cmEditor.doc.size)-1,
        document.createTextNode(error),
        { coverGutter: true, noHScroll: true, className: 'error-message' },
      )
  }

  for (const n of Array(count).keys()) {
    document.body.classList.add(`test-${n+1}-start`)
    const minWait = new Promise(s => setTimeout(s, 60))
    const pass = await send(n).catch(false)
    await minWait
    document.body.classList.remove(`test-${n+1}-start`)
    document.body.classList.add(`test-${n+1}-${pass ? 'pass' : 'fail'}`)
  }
}

const loadModule = ({ next, exercises }) => {
  const entries = Object.entries(exercises).map(([k, v], i) => [ k, { ...v, name: k, i }])
  for (const [,e] of entries) {
    e.prev = entries[e.i - 1] && entries[e.i - 1][1]
    e.next = entries[e.i + 1] && entries[e.i + 1][1]
  }
  _module = { next, entries, exercises: Object.fromEntries(entries) }
}

const loadHash = async (sourceHash, replace) => {
  if (_inPopState) return
  _inPopState = true
  const [exPath, versionPath=''] = sourceHash.replace(/^#(\/?)/, '').split('@')
  const version = versionPath
    ? defaults(unslash(versionPath).split('/'), 'nan-academy', 'js-training', 'gh-pages').join('/')
    : ''
  const url = version ? `${userContent}/${version}` : contentUrl
  const [mod, ex] = defaults(exPath.split('.'), 'browser-hello', 'hello')
  localStorage[`$${mod}.@${version}`]
    ? loadModule(JSON.parse(localStorage[`$${mod}.@${version}`]))
    : (await importText(await (await fetch(`${url}/module/${mod}.js`)).text()).then(exports => {
      const { next, exercises } = exports
      localStorage[`$${mod}.@${version}`] = JSON.stringify({ next, exercises })
      loadModule(exports)
    }))

  const exercise = _module.exercises[ex] || _module.entries[0] && _module.entries[0][1]
  if (!exercise) return cmEditor.setValue('Empty module')
  const hash = `#${mod}.${exercise.name}${version?`@${version}`:''}`
  hash === sourceHash || history[replace ? 'replaceState' : 'pushState']({}, '', `${baseUrl}${hash}`)
  const content = localStorage[hash] || (localStorage[hash] = await getContent(url, exercise.name))
  const [ subject ] = content.split('*/', 1)
  const testStartStr = 'export const tests = ['
  const [ base ] = content.split(testStartStr, 1)
  const start = subject.split('\n').length
  const size = base.split('\n').length - 1
  const testsText = content.slice(base.length + testStartStr.length)
  let count = 0

  _error && (_error.clear(), _error = undefined)
  document.body.className = ''
  cmEditor.setValue(content)
  cmEditor.focus()
  cmEditor.setCursor(start, 0)
  cmEditor.doc.markText({ line: 0, ch: 0 }, { line: start - 1, ch: 2 }, { readOnly: true })
  cmEditor.doc.markText({ line: 0, ch: 2 }, { line: start - 1, ch: 0 }, { className: 'subject' })
  cmEditor.doc.markText({ line: size, ch: 0 }, { line: cmEditor.doc.size + 1, ch: 0 }, { readOnly: true })
  testsText.replace(/\nt\(.+?=>/g, (match, index) => {
    const line = size + testsText.slice(0, index + match.length - 1).split('\n').length
    const matchLines = match.split('\n')
    const lastMatchedLine = matchLines[matchLines.length-1]
    const className = `test-flash test-${++count}`
    cmEditor.doc.markText({ line: line-1, ch: 0 }, { line, ch: 0 }, { className })
  })
  _inPopState = false
}

window.next = () => {
  const [ path, version = '' ] = location.hash.split('@')
  const [ mod, current ] = path.split('.')
  const next = _module.exercises[current] && _module.exercises[current].next
  if (next) return loadHash(`${mod}.${next.name}@${version}`)
  if (_module.next) return loadHash(`${_module.next}@${version}`)
  loadHash('success.congratulation@nan-academy/js-training')
}

const runTests = async () => {
  if (_lock) return
  _error && (_error.clear(), _error = undefined)
  await (_lock = exec(cmEditor.getValue())).finally(() => _lock = undefined)
  if (Array.from(document.body.classList).some(c => c.endsWith('-fail'))) return
  await new Promise(s => setTimeout(s, 250))
  next()
}

export const cmEditor = CodeMirror(document.getElementById('editor'), {
  mode: 'javascript',
  theme: DARK ? 'dracula' : 'neo',
  keyMap: 'sublime',
  tabSize: 2,
  lineNumbers: true,
  indentWithTabs: false,
  autoCloseBrackets: true,
  scrollbarStyle: 'null',
  extraKeys: { 'Ctrl-S': runTests, 'Cmd-S': runTests, 'Ctrl-Enter': runTests }
})

cmEditor.on('change', e => localStorage[location.hash] = e.getValue())
loadHash(location.hash, true)
  .catch(err => {
    console.error(err)
    localStorage.clear() && location.reload()
  })

addEventListener('hashchange', () => loadHash(location.hash, true))
  </script>
</body>
</html>